# ==============================================
# ENHANCED MEDIA HANDLING CONFIGURATION
# ==============================================
# Production-ready media configuration with:
# - Advanced caching strategies
# - Image optimization and transformation
# - CDN integration and fallback
# - Security headers and access controls
# - Bandwidth optimization
# - Progressive loading support
# ==============================================

# Image processing and caching
map $http_accept $webp_suffix {
    default "";
    "~*webp" ".webp";
}

map $http_accept $avif_suffix {
    default "";
    "~*avif" ".avif";
}

# Cache status tracking
map $upstream_cache_status $cache_header {
    MISS "MISS";
    HIT "HIT";
    EXPIRED "EXPIRED";
    STALE "STALE";
    UPDATING "UPDATING";
    REVALIDATED "REVALIDATED";
}

# Device pixel ratio detection
map $cookie_dpr $dpr {
    default 1;
    "~*(?:^|;)\s*dpr=([^;]+)" $1;
}

# Advanced media cache configuration
proxy_cache_path /var/cache/nginx/media 
    levels=2:2 
    keys_zone=media_cache:100m 
    max_size=10g 
    inactive=7d 
    use_temp_path=off
    loader_threshold=300 
    loader_files=200 
    loader_sleeps=1
    manager_files=300
    manager_threshold=200
    manager_sleep=1;

# Optimized image cache
proxy_cache_path /var/cache/nginx/images 
    levels=2:2:2 
    keys_zone=image_cache:200m 
    max_size=20g 
    inactive=30d 
    use_temp_path=off
    loader_threshold=500 
    loader_files=100;

# Video streaming cache
proxy_cache_path /var/cache/nginx/video 
    levels=1:2 
    keys_zone=video_cache:50m 
    max_size=5g 
    inactive=3d 
    use_temp_path=off;

# Custom cache key for responsive images
proxy_cache_key "$scheme$request_method$host$request_uri$dpr$webp_suffix$avif_suffix";

# ==============================================
# MAIN MEDIA SERVER BLOCK
# ==============================================

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name media.cryb.ai cdn.cryb.ai;
    
    # SSL Configuration
    ssl_certificate /etc/nginx/ssl/cryb.ai/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/cryb.ai/privkey.pem;
    
    # Advanced SSL optimization
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL_MEDIA:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 1.1.1.1 8.8.8.8 valid=300s;
    resolver_timeout 10s;
    
    # Security headers for media
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options SAMEORIGIN always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    # CORS headers for media assets
    add_header Access-Control-Allow-Origin "https://cryb.ai" always;
    add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Range, Content-Type, Accept, Accept-Encoding" always;
    add_header Access-Control-Expose-Headers "Accept-Ranges, Content-Encoding, Content-Length, Content-Range" always;
    add_header Access-Control-Max-Age 86400 always;
    
    # Cache control headers
    add_header X-Cache-Status $cache_header always;
    add_header X-Served-By "nginx-media" always;
    
    # Connection limits for media
    limit_conn perip 100;  # Higher limit for media requests
    
    # Gzip compression for text-based assets
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        image/svg+xml;
    
    # Brotli compression (if available)
    # brotli on;
    # brotli_comp_level 6;
    # brotli_types text/xml image/svg+xml application/json font/opentype text/css;
    
    # ==============================================
    # OPTIMIZED IMAGE SERVING
    # ==============================================
    
    # Responsive images with format selection
    location ~ ^/(?:cryb-avatars|cryb-media|cryb-thumbnails|cryb-emojis)/(.+)\.(jpe?g|png|gif|webp|avif)$ {
        set $bucket $1;
        set $file $2;
        set $ext $3;
        
        # Try modern formats first
        try_files 
            /optimized/$bucket/$file.avif$avif_suffix
            /optimized/$bucket/$file.webp$webp_suffix  
            /proxy/$bucket/$file.$ext
            @fallback;
        
        # Advanced caching
        proxy_cache image_cache;
        proxy_cache_valid 200 30d;
        proxy_cache_valid 404 1h;
        proxy_cache_use_stale error timeout invalid_header updating http_500 http_502 http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;
        proxy_cache_lock_timeout 10s;
        
        # Optimize headers
        expires 1y;
        add_header Cache-Control "public, immutable" always;
        add_header Vary "Accept, Accept-Encoding" always;
        
        # Security
        add_header Content-Security-Policy "default-src 'none'; img-src 'self'; style-src 'unsafe-inline'" always;
        
        # Remove unnecessary headers
        proxy_hide_header Set-Cookie;
        proxy_hide_header X-Powered-By;
        proxy_ignore_headers Set-Cookie;
    }
    
    # Image transformation and optimization endpoint
    location ~ ^/transform/(?<width>\d+)x(?<height>\d+)/(?<quality>\d+)/(?<bucket>[\w-]+)/(?<filename>.+)$ {
        # Proxy to image processing service
        proxy_pass http://api_backend/api/v1/media/transform?width=$width&height=$height&quality=$quality&bucket=$bucket&filename=$filename;
        proxy_http_version 1.1;
        
        proxy_cache image_cache;
        proxy_cache_valid 200 7d;
        proxy_cache_valid 404 1h;
        proxy_cache_key "$scheme$request_method$host$uri$width$height$quality$webp_suffix";
        
        # Cache transformed images aggressively
        expires 7d;
        add_header Cache-Control "public, immutable";
        add_header X-Transformed "nginx-$width-$height-$quality";
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # ==============================================
    # VIDEO STREAMING WITH ADAPTIVE BITRATE
    # ==============================================
    
    location ~ ^/(?:cryb-media)/(.+)\.(mp4|webm|mov|avi)$ {
        set $video_file $1.$2;
        
        # Range request support for video streaming
        proxy_force_ranges on;
        proxy_cache video_cache;
        proxy_cache_valid 200 3d;
        proxy_cache_valid 206 1h;  # Partial content
        proxy_cache_key "$scheme$request_method$host$request_uri$http_range";
        
        # Video streaming headers
        add_header Accept-Ranges bytes always;
        add_header Cache-Control "public, max-age=259200" always;  # 3 days
        
        # Proxy to MinIO with streaming optimization
        proxy_pass http://minio_backend/cryb-media/$video_file;
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_request_buffering off;
        
        # Extended timeouts for large videos
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Range $http_range;
    }
    
    # HLS streaming support
    location ~ \.(m3u8|ts)$ {
        proxy_cache video_cache;
        proxy_cache_valid 200 1m;
        
        add_header Cache-Control "max-age=60" always;
        add_header Access-Control-Allow-Origin "*" always;
        
        proxy_pass http://minio_backend;
        proxy_http_version 1.1;
        proxy_buffering off;
    }
    
    # ==============================================
    # DIRECT MINIO PROXY WITH OPTIMIZATION
    # ==============================================
    
    location @fallback {
        # Direct MinIO access as fallback
        rewrite ^/(.+)$ /$1 break;
        proxy_pass http://minio_backend;
        proxy_http_version 1.1;
        
        proxy_cache media_cache;
        proxy_cache_valid 200 1d;
        proxy_cache_valid 404 1h;
        proxy_cache_use_stale error timeout invalid_header updating;
        
        # Basic optimization headers
        expires 1d;
        add_header Cache-Control "public";
        add_header X-Fallback "true";
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # Bucket-specific routes
    location /cryb-avatars/ {
        proxy_cache image_cache;
        proxy_cache_valid 200 7d;
        proxy_cache_use_stale error timeout invalid_header updating;
        
        expires 7d;
        add_header Cache-Control "public, immutable";
        add_header X-Content-Type "avatar";
        
        proxy_pass http://minio_backend;
        proxy_http_version 1.1;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /cryb-thumbnails/ {
        proxy_cache image_cache;
        proxy_cache_valid 200 30d;
        proxy_cache_use_stale error timeout invalid_header updating;
        
        expires 30d;
        add_header Cache-Control "public, immutable";
        add_header X-Content-Type "thumbnail";
        
        proxy_pass http://minio_backend;
        proxy_http_version 1.1;
    }
    
    # ==============================================
    # UPLOAD ENDPOINTS
    # ==============================================
    
    location /upload {
        # Rate limiting for uploads
        limit_req zone=upload burst=10 nodelay;
        
        # Large file upload support
        client_max_body_size 1000m;
        proxy_request_buffering off;
        proxy_buffering off;
        
        # Disable caching for uploads
        proxy_cache off;
        add_header Cache-Control "no-cache, no-store, must-revalidate" always;
        
        # Extended timeouts for large uploads
        proxy_connect_timeout 60s;
        proxy_send_timeout 600s;
        proxy_read_timeout 600s;
        
        proxy_pass http://api_backend/api/v1/uploads;
        proxy_http_version 1.1;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Upload-Endpoint "nginx-media";
    }
    
    # ==============================================
    # CDN MANAGEMENT ENDPOINTS
    # ==============================================
    
    location /purge {
        # Restrict to admin IPs only
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        deny all;
        
        # Purge cache
        proxy_cache_purge media_cache $scheme$request_method$host$request_uri;
        proxy_cache_purge image_cache $scheme$request_method$host$request_uri;
        proxy_cache_purge video_cache $scheme$request_method$host$request_uri;
        
        add_header X-Cache-Purged "true" always;
    }
    
    # Cache statistics
    location /cache/stats {
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        deny all;
        
        stub_status on;
        access_log off;
    }
    
    # ==============================================
    # HEALTH AND MONITORING
    # ==============================================
    
    location /health {
        access_log off;
        
        # Check MinIO backend health
        proxy_pass http://minio_backend/minio/health/live;
        proxy_http_version 1.1;
        proxy_connect_timeout 5s;
        proxy_send_timeout 5s;
        proxy_read_timeout 5s;
        
        add_header X-Health-Check "media-server" always;
    }
    
    location /metrics {
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        deny all;
        
        access_log off;
        
        # Basic metrics endpoint
        return 200 "# TYPE nginx_cache_size_bytes gauge\nnginx_cache_size_bytes{cache=\"media\"} 0\n";
        add_header Content-Type "text/plain";
    }
    
    # ==============================================
    # ERROR PAGES
    # ==============================================
    
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    
    location = /404.html {
        internal;
        return 404 "Media not found";
        add_header Content-Type "text/plain";
    }
    
    location = /50x.html {
        internal;
        return 500 "Media server error";
        add_header Content-Type "text/plain";
    }
    
    # ==============================================
    # SECURITY RULES
    # ==============================================
    
    # Block access to sensitive files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Block access to backup files
    location ~ ~$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Prevent hotlinking (optional)
    location ~ \.(jpg|jpeg|png|gif|webp|avif|mp4|webm)$ {
        valid_referers none blocked server_names
            *.cryb.ai cryb.ai
            ~\.google\. ~\.bing\. ~\.yahoo\.
            ~\.facebook\. ~\.twitter\.;
        
        if ($invalid_referer) {
            return 403 "Hotlinking not allowed";
        }
    }
}

# ==============================================
# HTTP TO HTTPS REDIRECT FOR MEDIA
# ==============================================

server {
    listen 80;
    listen [::]:80;
    server_name media.cryb.ai cdn.cryb.ai;
    
    # ACME challenge for Let's Encrypt
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/certbot;
        try_files $uri =404;
    }
    
    # Redirect all other requests to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}