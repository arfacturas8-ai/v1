#!/usr/bin/env node

/**
 * Comprehensive test script for Discord-style community features
 * 
 * This script tests:
 * 1. Server creation and management
 * 2. Channel creation and management
 * 3. Real-time messaging
 * 4. Typing indicators
 * 5. Message reactions
 * 6. Message editing/deletion
 * 7. Server invites
 * 8. Member management
 * 9. Voice channel states
 * 10. Presence tracking
 */

const axios = require('axios');
const io = require('socket.io-client');
const crypto = require('crypto');

const API_BASE = 'http://localhost:3001';
const SOCKET_URL = 'http://localhost:3001';

// Test users
const users = [
  { username: 'testuser1', email: 'test1@example.com', password: 'password123' },
  { username: 'testuser2', email: 'test2@example.com', password: 'password123' },
  { username: 'testuser3', email: 'test3@example.com', password: 'password123' }
];

let authTokens = {};
let sockets = {};
let testServer = null;
let testChannels = [];

// Color codes for output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

function log(color, message, ...args) {
  console.log(color + message + colors.reset, ...args);
}\n\nfunction success(message, ...args) {\n  log(colors.green, 'âœ… ' + message, ...args);\n}\n\nfunction error(message, ...args) {\n  log(colors.red, 'âŒ ' + message, ...args);\n}\n\nfunction info(message, ...args) {\n  log(colors.blue, 'â„¹ï¸  ' + message, ...args);\n}\n\nfunction warning(message, ...args) {\n  log(colors.yellow, 'âš ï¸  ' + message, ...args);\n}\n\n// Helper function to make authenticated API calls\nasync function apiCall(method, endpoint, data = null, userIndex = 0) {\n  try {\n    const config = {\n      method,\n      url: `${API_BASE}${endpoint}`,\n      headers: {\n        'Authorization': `Bearer ${authTokens[users[userIndex].username]}`,\n        'Content-Type': 'application/json'\n      }\n    };\n\n    if (data) {\n      config.data = data;\n    }\n\n    const response = await axios(config);\n    return response.data;\n  } catch (err) {\n    if (err.response) {\n      throw new Error(`API Error: ${err.response.status} - ${JSON.stringify(err.response.data)}`);\n    }\n    throw err;\n  }\n}\n\n// Test user registration and authentication\nasync function testAuthentication() {\n  info('ðŸ” Testing authentication...');\n  \n  for (const user of users) {\n    try {\n      // Try to register (may fail if user exists)\n      try {\n        const registerResponse = await axios.post(`${API_BASE}/api/v1/auth/register`, {\n          username: user.username,\n          email: user.email,\n          password: user.password,\n          displayName: `Test User ${user.username.slice(-1)}`\n        });\n        success(`Registered user: ${user.username}`);\n      } catch (regError) {\n        warning(`User ${user.username} already exists or registration failed`);\n      }\n\n      // Login\n      const loginResponse = await axios.post(`${API_BASE}/api/v1/auth/login`, {\n        username: user.username,\n        password: user.password\n      });\n\n      if (loginResponse.data.success && loginResponse.data.data.accessToken) {\n        authTokens[user.username] = loginResponse.data.data.accessToken;\n        success(`Logged in user: ${user.username}`);\n      } else {\n        throw new Error('Login failed');\n      }\n    } catch (err) {\n      error(`Authentication failed for ${user.username}:`, err.message);\n      throw err;\n    }\n  }\n\n  success('All users authenticated successfully');\n}\n\n// Test server creation and management\nasync function testServerManagement() {\n  info('ðŸ° Testing server management...');\n  \n  try {\n    // Create a test server\n    const serverData = {\n      name: 'Test Gaming Community',\n      description: 'A test server for gaming enthusiasts',\n      category: 'gaming',\n      isPublic: true,\n      discoverable: true,\n      maxMembers: 1000\n    };\n\n    const createResponse = await apiCall('POST', '/api/v1/servers', serverData, 0);\n    if (!createResponse.success) {\n      throw new Error('Server creation failed');\n    }\n\n    testServer = createResponse.data;\n    success(`Created server: ${testServer.name} (ID: ${testServer.id})`);\n\n    // Get server details\n    const getResponse = await apiCall('GET', `/api/v1/servers/${testServer.id}`, null, 0);\n    if (getResponse.success) {\n      success(`Retrieved server details: ${getResponse.data.name}`);\n      testChannels = getResponse.data.channels || [];\n      info(`Server has ${testChannels.length} default channels`);\n    }\n\n    // Update server\n    const updateData = {\n      description: 'Updated description for the gaming community'\n    };\n    const updateResponse = await apiCall('PATCH', `/api/v1/servers/${testServer.id}`, updateData, 0);\n    if (updateResponse.success) {\n      success('Updated server description');\n    }\n\n    // Test server discovery\n    const discoveryResponse = await apiCall('GET', '/api/v1/servers/discover?category=gaming', null, 0);\n    if (discoveryResponse.success) {\n      success(`Found ${discoveryResponse.data.servers.length} servers in discovery`);\n    }\n\n  } catch (err) {\n    error('Server management test failed:', err.message);\n    throw err;\n  }\n}\n\n// Test channel creation and management\nasync function testChannelManagement() {\n  info('ðŸ“º Testing channel management...');\n  \n  try {\n    // Create text channel\n    const textChannelData = {\n      serverId: testServer.id,\n      name: 'test-chat',\n      type: 'TEXT',\n      description: 'A test text channel',\n      slowMode: 5\n    };\n\n    const textChannelResponse = await apiCall('POST', '/api/v1/channels', textChannelData, 0);\n    if (textChannelResponse.success) {\n      testChannels.push(textChannelResponse.data);\n      success(`Created text channel: ${textChannelResponse.data.name}`);\n    }\n\n    // Create voice channel\n    const voiceChannelData = {\n      serverId: testServer.id,\n      name: 'Gaming Voice',\n      type: 'VOICE',\n      description: 'Voice channel for gaming'\n    };\n\n    const voiceChannelResponse = await apiCall('POST', '/api/v1/channels', voiceChannelData, 0);\n    if (voiceChannelResponse.success) {\n      testChannels.push(voiceChannelResponse.data);\n      success(`Created voice channel: ${voiceChannelResponse.data.name}`);\n    }\n\n    // Create category\n    const categoryData = {\n      serverId: testServer.id,\n      name: 'Gaming Channels',\n      type: 'CATEGORY',\n      description: 'Category for gaming channels'\n    };\n\n    const categoryResponse = await apiCall('POST', '/api/v1/channels', categoryData, 0);\n    if (categoryResponse.success) {\n      testChannels.push(categoryResponse.data);\n      success(`Created category: ${categoryResponse.data.name}`);\n    }\n\n    // Update channel\n    const updateData = {\n      name: 'updated-test-chat',\n      topic: 'This is an updated test channel'\n    };\n    const updateResponse = await apiCall('PATCH', `/api/v1/channels/${textChannelResponse.data.id}`, updateData, 0);\n    if (updateResponse.success) {\n      success('Updated channel name and topic');\n    }\n\n  } catch (err) {\n    error('Channel management test failed:', err.message);\n    throw err;\n  }\n}\n\n// Test invite system\nasync function testInviteSystem() {\n  info('ðŸ“§ Testing invite system...');\n  \n  try {\n    // Create invite\n    const inviteData = {\n      maxUses: 10,\n      maxAge: 3600, // 1 hour\n      temporary: false\n    };\n\n    const createInviteResponse = await apiCall('POST', `/api/v1/servers/${testServer.id}/invites`, inviteData, 0);\n    if (createInviteResponse.success) {\n      const invite = createInviteResponse.data;\n      success(`Created invite: ${invite.code}`);\n\n      // Get server invites\n      const getInvitesResponse = await apiCall('GET', `/api/v1/servers/${testServer.id}/invites`, null, 0);\n      if (getInvitesResponse.success) {\n        success(`Retrieved ${getInvitesResponse.data.length} invites`);\n      }\n\n      // Use invite with different user\n      const acceptInviteResponse = await apiCall('POST', `/api/v1/servers/invites/${invite.code}/accept`, null, 1);\n      if (acceptInviteResponse.success) {\n        success(`User ${users[1].username} joined server via invite`);\n      }\n\n      // Third user also joins via invite\n      const acceptInviteResponse2 = await apiCall('POST', `/api/v1/servers/invites/${invite.code}/accept`, null, 2);\n      if (acceptInviteResponse2.success) {\n        success(`User ${users[2].username} joined server via invite`);\n      }\n    }\n\n  } catch (err) {\n    error('Invite system test failed:', err.message);\n    throw err;\n  }\n}\n\n// Test socket connections\nasync function testSocketConnections() {\n  info('ðŸ”Œ Testing Socket.io connections...');\n  \n  return new Promise((resolve, reject) => {\n    let connectedCount = 0;\n    const targetCount = users.length;\n\n    users.forEach((user, index) => {\n      const socket = io(SOCKET_URL, {\n        auth: {\n          token: authTokens[user.username]\n        },\n        transports: ['websocket']\n      });\n\n      socket.on('connect', () => {\n        success(`Socket connected for ${user.username}`);\n        connectedCount++;\n        \n        if (connectedCount === targetCount) {\n          success('All socket connections established');\n          resolve();\n        }\n      });\n\n      socket.on('connect_error', (err) => {\n        error(`Socket connection failed for ${user.username}:`, err.message);\n        reject(err);\n      });\n\n      socket.on('ready', (data) => {\n        success(`Received ready event for ${user.username}:`, data.user.username);\n      });\n\n      socket.on('error', (err) => {\n        warning(`Socket error for ${user.username}:`, err.message);\n      });\n\n      sockets[user.username] = socket;\n    });\n\n    setTimeout(() => {\n      if (connectedCount < targetCount) {\n        reject(new Error('Socket connection timeout'));\n      }\n    }, 10000);\n  });\n}\n\n// Test real-time messaging\nasync function testRealtimeMessaging() {\n  info('ðŸ’¬ Testing real-time messaging...');\n  \n  return new Promise((resolve, reject) => {\n    let messageReceived = false;\n    const testChannel = testChannels.find(c => c.type === 'TEXT');\n    \n    if (!testChannel) {\n      reject(new Error('No text channel found for testing'));\n      return;\n    }\n\n    // Set up message listener on user2's socket\n    sockets[users[1].username].on('message:create', (message) => {\n      if (message.content === 'Hello from real-time test!') {\n        success('Real-time message received successfully');\n        messageReceived = true;\n        resolve();\n      }\n    });\n\n    // User1 joins the channel and sends a message\n    sockets[users[0].username].emit('channel:join', {\n      channelId: testChannel.id\n    });\n\n    sockets[users[1].username].emit('channel:join', {\n      channelId: testChannel.id\n    });\n\n    // Wait a moment then send message\n    setTimeout(() => {\n      sockets[users[0].username].emit('message:create', {\n        channelId: testChannel.id,\n        content: 'Hello from real-time test!',\n        nonce: crypto.randomUUID()\n      });\n    }, 500);\n\n    // Timeout after 5 seconds\n    setTimeout(() => {\n      if (!messageReceived) {\n        reject(new Error('Real-time message test timeout'));\n      }\n    }, 5000);\n  });\n}\n\n// Test typing indicators\nasync function testTypingIndicators() {\n  info('âŒ¨ï¸  Testing typing indicators...');\n  \n  return new Promise((resolve, reject) => {\n    let typingReceived = false;\n    const testChannel = testChannels.find(c => c.type === 'TEXT');\n    \n    if (!testChannel) {\n      reject(new Error('No text channel found for testing'));\n      return;\n    }\n\n    // Set up typing listener on user2's socket\n    sockets[users[1].username].on('channel:typing_start', (data) => {\n      if (data.user_id === users[0].username) {\n        success('Typing indicator received successfully');\n        typingReceived = true;\n        resolve();\n      }\n    });\n\n    // User1 starts typing\n    setTimeout(() => {\n      sockets[users[0].username].emit('channel:typing', {\n        channelId: testChannel.id\n      });\n    }, 500);\n\n    // Timeout after 3 seconds\n    setTimeout(() => {\n      if (!typingReceived) {\n        reject(new Error('Typing indicator test timeout'));\n      }\n    }, 3000);\n  });\n}\n\n// Test message reactions\nasync function testMessageReactions() {\n  info('ðŸ‘ Testing message reactions...');\n  \n  try {\n    const testChannel = testChannels.find(c => c.type === 'TEXT');\n    if (!testChannel) {\n      throw new Error('No text channel found');\n    }\n\n    // Create a message via API first\n    const messageData = {\n      channelId: testChannel.id,\n      content: 'This message will get reactions!'\n    };\n\n    const messageResponse = await apiCall('POST', '/api/v1/messages', messageData, 0);\n    if (!messageResponse.success) {\n      throw new Error('Failed to create message for reaction test');\n    }\n\n    const message = messageResponse.data;\n    success(`Created message for reaction test: ${message.id}`);\n\n    // Add reaction via API\n    const reactionData = {\n      emoji: 'ðŸ‘'\n    };\n\n    const reactionResponse = await apiCall('POST', `/api/v1/messages/${message.id}/reactions`, reactionData, 1);\n    if (reactionResponse.success) {\n      success('Added reaction to message');\n    }\n\n    // Remove reaction\n    const removeReactionResponse = await apiCall('POST', `/api/v1/messages/${message.id}/reactions`, reactionData, 1);\n    if (removeReactionResponse.success) {\n      success('Removed reaction from message');\n    }\n\n  } catch (err) {\n    error('Message reaction test failed:', err.message);\n    throw err;\n  }\n}\n\n// Test message editing\nasync function testMessageEditing() {\n  info('âœï¸  Testing message editing...');\n  \n  try {\n    const testChannel = testChannels.find(c => c.type === 'TEXT');\n    if (!testChannel) {\n      throw new Error('No text channel found');\n    }\n\n    // Create a message\n    const messageData = {\n      channelId: testChannel.id,\n      content: 'This message will be edited'\n    };\n\n    const messageResponse = await apiCall('POST', '/api/v1/messages', messageData, 0);\n    if (!messageResponse.success) {\n      throw new Error('Failed to create message for edit test');\n    }\n\n    const message = messageResponse.data;\n    success(`Created message for edit test: ${message.id}`);\n\n    // Edit the message\n    const editData = {\n      content: 'This message has been edited!'\n    };\n\n    const editResponse = await apiCall('PATCH', `/api/v1/messages/${message.id}`, editData, 0);\n    if (editResponse.success) {\n      success('Successfully edited message');\n    }\n\n  } catch (err) {\n    error('Message editing test failed:', err.message);\n    throw err;\n  }\n}\n\n// Test voice channel functionality\nasync function testVoiceChannels() {\n  info('ðŸŽ¤ Testing voice channels...');\n  \n  return new Promise((resolve, reject) => {\n    let voiceStateReceived = false;\n    const voiceChannel = testChannels.find(c => c.type === 'VOICE');\n    \n    if (!voiceChannel) {\n      reject(new Error('No voice channel found for testing'));\n      return;\n    }\n\n    // Set up voice state listener\n    sockets[users[1].username].on('voice:state_update', (state) => {\n      if (state.userId === users[0].username && state.channelId === voiceChannel.id) {\n        success('Voice state update received successfully');\n        voiceStateReceived = true;\n        resolve();\n      }\n    });\n\n    // User1 joins voice channel\n    setTimeout(() => {\n      sockets[users[0].username].emit('voice:join', {\n        channelId: voiceChannel.id\n      });\n    }, 500);\n\n    // Timeout after 5 seconds\n    setTimeout(() => {\n      if (!voiceStateReceived) {\n        reject(new Error('Voice channel test timeout'));\n      }\n    }, 5000);\n  });\n}\n\n// Test presence system\nasync function testPresenceSystem() {\n  info('ðŸŸ¢ Testing presence system...');\n  \n  return new Promise((resolve, reject) => {\n    let presenceReceived = false;\n\n    // Set up presence listener\n    sockets[users[1].username].on('presence:update', (presence) => {\n      if (presence.user_id === users[0].username && presence.status === 'dnd') {\n        success('Presence update received successfully');\n        presenceReceived = true;\n        resolve();\n      }\n    });\n\n    // User1 updates presence\n    setTimeout(() => {\n      sockets[users[0].username].emit('presence:update', {\n        status: 'dnd',\n        activity: {\n          type: 'playing',\n          name: 'Test Game',\n          details: 'In a test match'\n        }\n      });\n    }, 500);\n\n    // Timeout after 3 seconds\n    setTimeout(() => {\n      if (!presenceReceived) {\n        reject(new Error('Presence system test timeout'));\n      }\n    }, 3000);\n  });\n}\n\n// Test member management\nasync function testMemberManagement() {\n  info('ðŸ‘¥ Testing member management...');\n  \n  try {\n    // Get server members\n    const membersResponse = await apiCall('GET', `/api/v1/servers/${testServer.id}/members`, null, 0);\n    if (membersResponse.success) {\n      success(`Retrieved ${membersResponse.data.items.length} server members`);\n    }\n\n    // Test server member request via socket\n    return new Promise((resolve, reject) => {\n      sockets[users[0].username].on('server:members_chunk', (data) => {\n        if (data.server_id === testServer.id) {\n          success(`Received ${data.members.length} members via socket`);\n          resolve();\n        }\n      });\n\n      sockets[users[0].username].emit('server:request_members', {\n        serverId: testServer.id,\n        limit: 50\n      });\n\n      setTimeout(() => {\n        reject(new Error('Member management test timeout'));\n      }, 5000);\n    });\n\n  } catch (err) {\n    error('Member management test failed:', err.message);\n    throw err;\n  }\n}\n\n// Clean up test data\nasync function cleanup() {\n  info('ðŸ§¹ Cleaning up test data...');\n  \n  try {\n    // Close socket connections\n    Object.values(sockets).forEach(socket => {\n      if (socket && socket.connected) {\n        socket.disconnect();\n      }\n    });\n    success('Closed all socket connections');\n\n    // Delete test server (this will cascade delete channels, messages, etc.)\n    if (testServer) {\n      const deleteResponse = await apiCall('DELETE', `/api/v1/servers/${testServer.id}`, null, 0);\n      if (deleteResponse.success) {\n        success('Deleted test server and related data');\n      }\n    }\n\n  } catch (err) {\n    warning('Cleanup encountered errors:', err.message);\n  }\n}\n\n// Main test runner\nasync function runAllTests() {\n  try {\n    log(colors.cyan, '\\nðŸš€ Starting Discord-style Community Features Test\\n');\n    \n    await testAuthentication();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testServerManagement();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testChannelManagement();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testInviteSystem();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testSocketConnections();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testRealtimeMessaging();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testTypingIndicators();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testMessageReactions();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testMessageEditing();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testVoiceChannels();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testPresenceSystem();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    await testMemberManagement();\n    log(colors.white, '\\n' + '='.repeat(50) + '\\n');\n    \n    success('\\nðŸŽ‰ All tests passed successfully!');\n    \n    log(colors.cyan, '\\nðŸ“Š Test Summary:');\n    log(colors.white, 'âœ… Authentication system');\n    log(colors.white, 'âœ… Server management (CRUD)');\n    log(colors.white, 'âœ… Channel management (TEXT/VOICE/CATEGORY)');\n    log(colors.white, 'âœ… Invite system with expiration');\n    log(colors.white, 'âœ… Real-time Socket.io connections');\n    log(colors.white, 'âœ… Real-time messaging');\n    log(colors.white, 'âœ… Typing indicators');\n    log(colors.white, 'âœ… Message reactions');\n    log(colors.white, 'âœ… Message editing');\n    log(colors.white, 'âœ… Voice channel states');\n    log(colors.white, 'âœ… Presence system');\n    log(colors.white, 'âœ… Member management');\n    \n  } catch (err) {\n    error('\\nðŸ’¥ Test failed:', err.message);\n    console.error(err);\n    process.exit(1);\n  } finally {\n    await cleanup();\n  }\n}\n\n// Run tests if called directly\nif (require.main === module) {\n  runAllTests().then(() => {\n    log(colors.green, '\\nâœ¨ All Discord-style features working perfectly!');\n    process.exit(0);\n  }).catch((err) => {\n    error('Test suite failed:', err.message);\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  runAllTests,\n  testAuthentication,\n  testServerManagement,\n  testChannelManagement,\n  testInviteSystem,\n  testSocketConnections,\n  testRealtimeMessaging,\n  testTypingIndicators,\n  testMessageReactions,\n  testMessageEditing,\n  testVoiceChannels,\n  testPresenceSystem,\n  testMemberManagement\n};